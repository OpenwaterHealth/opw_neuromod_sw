classdef FourUp < fus.DataClass
    % FOURUP 4-up display of 3D data
    %   FOURUP(vol, cmap) creates a 4-up display of the 3D data in VOLUME
    properties (SetAccess=protected, GetAccess=public)
        volume (1,:) fus.Volume % The volume or volume array to display
        cmap (1,:) fus.ColorMapper % array of ColorMapper objects, one for each volume
        points (1,:) fus.Point % optional points
        indices (1,3) double {mustBeInteger} % The indices of the current slice
        values (1,3) double % The values of the current slice
        axis_margin (1,1) double {mustBePositive} = 0.05 % The margin the axes when creating a figure
        axes (1,:) {fus.util.mustBeAxes} = matlab.ui.control.UIAxes.empty % The axes to plot into
        colorbar_axes (1,:) {fus.util.mustBeAxes} = matlab.ui.control.UIAxes.empty % The axes to plot into
        colorbar_dropdown
        cmap_ui
        image_handles % The image handles
        surface_handles % The surface handles
        crosshairs % The crosshair handles
        point_handles % Point patch handles
        point_surfs % Point surface handles
        xdim (1,3) string = ["","",""] % The x dimension order
        ydim (1,3) string = ["","",""] % The y dimension order
        zdim (1,3) string = ["","",""] % The z dimension order
    end
    
    properties (Access=protected)
        links % property links
        next_render (1,1) string = "" % The id of the queued render
        render_busy (1,1) logical = false % True if a render is in progress
    end
    
    properties (Access=public)
        on_update function_handle = function_handle.empty % Function to call when the slice changes
    end
    
    methods
        function self = FourUp(volume, cmap, options)
            % FOURUP 4-up display of 3D data
    
            % f = FOURUP(vol, cmap, 'param', value, ...)
            
            % FOURUP generates three slices of the 3D data in an array of volumes,
            % with color data generated by the colormap array. Each slice is drawn
            % in a separate axes, with the fourth axes showing all three slices simultaneously.
            % When the user clicks on a slice, the other slices are updated to show the same
            % location in the other dimensions.
            
            % Inputs:
            %   vol (fus.Volume or array-like): The volume or volume array to display.
            %   cmap (Colormap or array-like): The colormap or colormap array to use.
            
            % Optional Parameters:
            %   parent: graphical parent (if axes are not provided).
            %       Default [] (Make a new uifigure).
            %   axes (list of 4 axes): The axes to plot into.
            %   axes_arrangement (2D array specifiying axes arrangement by
            %       integer. 1,2,3 are the slices. 4 is the 3D axis. -1 is
            %       the colorbar, 0 is not drawn. Default [1,2;3 4].
            %   points (array-like): Points to plot.
            %   xdim (array-like of 3 strings): The x dimension order.
            %   ydim (array-like of 3 strings): The y dimension order.
            %   zdim (array-like of 3 strings): The z dimension order.
            %   values (array-like of 3 values): The initial values.
            %   colorbar (logical) add interactive colorbar
            %   colorbar_width (double) set colorbar width relative to
            %       axes. Default 0.3. Not used if axes_arrangement
            %       includes the colorbar.
            %   axes_props (dict): Optional axes properties.
            %   fig_props (dict): Optional figure properties.
            %   line_props (dict): Optional line properties.
            %   point_props (dict): Optional point properties.
            %   padding (float): The padding between axes. Default: 40.
            %   spacing (float): The spacing between axes. Default: 40.
            %   on_update (function): Function to call when the slice changes.
            
            % Returns:
            %   f (figure): The figure containing the 4-up display.
            arguments
                volume (1,:) fus.Volume
                cmap (1,:) fus.ColorMapper = fus.ColorMapper.from_volume(volume)
                options.parent = []
                options.axes (1,4) {fus.util.mustBeAxes}
                options.axes_arrangement double {mustBeInteger, mustBeInRange(options.axes_arrangement, 0, 4)}= [1 2; 3 4];
                options.points (1,:) fus.Point
                options.xdim (1,3) string
                options.ydim (1,3) string
                options.zdim (1,3) string
                options.values (1,:) double = []
                options.colorbar (1,1) logical = false
                options.colorbar_width (1,1) double {mustBePositive} = 0.3;
                options.axes_props (1,1) struct = struct;
                options.fig_props (1,1) struct = struct;
                options.line_props (1,1) struct = struct;
                options.point_props (1,1) struct = struct('FaceAlpha', 0.2)
                options.padding (1,1) double = 40
                options.spacing (1,1) double = 40
                options.on_update function_handle = function_handle.empty
            end
            self.volume = volume;
            self.cmap = cmap;
            if isfield(options, 'axes')
                self.axes = options.axes;
                for i = 1:length(self.axes)
                    cla(self.axes(i));
                end
                axes_args = fus.util.struct2args(options.axes_props);
                if ~isempty(axes_args)
                    set(self.axes, axes_args{:});
                end
            else
                self.initialize_axes(...
                    "padding", options.padding, ...
                    "spacing", options.spacing, ...
                    "parent", options.parent, ...
                    "axes_arrangement", options.axes_arrangement, ...
                    "axes_props", options.axes_props, ...
                    "colorbar", options.colorbar, ...
                    "colorbar_width", options.colorbar_width, ...
                    "fig_props", options.fig_props);
            end
            self.parse_props(options, ["xdim","ydim","zdim","on_update","points"]);
            self.initialize_dims()
            self.initialize_values(options.values)
            self.create_images_surfaces(...
                "line_props", options.line_props, ...
                "point_props", options.point_props)
        end
        
        function ax = axes_3D(self)
            % AXES_3D get the 3D axis handle
            ax = self.axes(4);
        end
              
        function reset_view(self)
            % RESET_VIEW Reset the view
            %   f.RESET_VIEW() resets the view to the default
            extent = arrayfun(@extent, self.volume.get_coords, 'UniformOutput', false);
            cam_settings = self.get_cam_settings(1:3);
            for ax_index = 1:3
                ax = self.axes(ax_index);
                args = fus.util.struct2args(cam_settings(ax_index));
                set(ax,args{:}); 
            end
            view_extent = cellfun(@(x)x+[-1;1]*diff(x)*self.axis_margin, extent, 'UniformOutput', false);
            axis(self.axes(end),cat(1,view_extent{:}),'xy')
            view(self.axes(end),30,30);   
        end
        
        function indices = get_indices(self)
            % GET_INDICES Get the current indices
            %   indices = f.GET_INDICES() returns the current indices
            arguments
                self fus.ui.FourUp
            end
            indices = self.indices;
        end
        
        function tab = get_table(self)
            % GET_TABLE Get the current slice values and voxel values as a table
            %   tab = f.GET_TABLE() returns the current slice values and voxel values as a table
            coords = self.volume.get_coords();
            C = cell(3+length(self.volume),3);
            for i = 1:3
                C{i,1} = coords(i).name;
                C{i,2} = sprintf('%0.3g', self.values(i));
                C{i,3} = coords(i).units;
            end
            idx = num2cell(self.indices);
            for i = 1:length(self.volume)
                C{3+i,1} = self.volume(i).name;
                C{3+i,2} = sprintf('%0.3g', self.volume(i).data(idx{:}));
                C{3+i,3} = self.volume(i).units;
            end
            tab = array2table(C, "VariableNames", ["Param", "Value", "Units"]);
        end
            
        function values = get_values(self, options)
            % GET_VALUES Get the current values
            %   values = f.GET_VALUES() returns the current values
            arguments
                self fus.ui.FourUp
                options.units (1,1) string = self.volume.get_units
            end
            values = self.values * fus.util.getunitconversion(self.volume.get_units, options.units);
        end
        
        function M = get_frame(self, options)
            % GET_FRAME Get screenshot of axes
            %   M = f.get_frame()
            %   M = f.get_frame("stack", true)
            %
            arguments
                self fus.ui.FourUp
                options.stack (1,1) logical = false
            end
            figs = ancestor(self.axes, "Figure");
            if all(cellfun(@(x)x==figs{1}, figs))
                M = getframe(figs{1});
            else
                M = cellfun(@(f)getframe(f), figs);
                if options.stack
                    h = arrayfun(@(m)size(m.cdata,1), M);
                    w = arrayfun(@(m)size(m.cdata,2), M);
                    cdata = zeros(max(h),sum(w),3, 'uint8');
                    for i = 1:length(M)
                        cdata(1:h(i),sum(w(1:i))+[-(w(i)-1):0],:) = M(i).cdata;
                    end
                    M = struct('cdata',cdata, 'colormap', []);
                end
            end
        end
        
        function set_indices(self, indices)
            % SET_INDICES Set the current indices
            %   f.SET_INDICES(indices) sets the current indices and updates the slices
            %
            % Inputs:
            %   indices (1x3 array): The indices to set.
            if self.render_busy
                return
            end
            coords = self.volume.get_coords;
            self.indices = indices;
            self.values = arrayfun(@(i)coords(i).values(self.indices(i)), [1,2,3]);
            self.update()
        end
        
        function set_values(self, values, options)
            % SET_VALUES Set the current values
            %   f.SET_VALUES(values) sets the current values and updates the slices.
            %
            % Inputs:
            %   values (1x3 array): The values to set.
            %
            % Optional Parameters:
            %   units (string): The units of the values. Default is the volume coordinate units.
            arguments
                self fus.ui.FourUp
                values (1,3) double
                options.units (1,1) string = self.volume.get_units
            end
            if self.render_busy
                return
            end
            scl = fus.util.getunitconversion(options.units, self.volume.get_units);
            coords = self.volume.get_coords;
            for i = 1:3
                coord = coords(i);
                set_indices(i) = interp1(coord.values, 1:coord.length, values(i)*scl, 'nearest');
                if isnan(set_indices(i))
                    ext = coord.extent();
                    error('Requested value for %s (%0.4g%s) is outside of the valid range [%0.4g%s,%0.4g%s].', coord.name, values(i), options.units, ext(1), coord.units, ext(2), coord.units);
                end
                set_values(i) = coord.values(set_indices(i));
            end
            self.indices = set_indices;
            self.values = set_values;
            self.update();
        end
        
        function update(self, uuid)
            % UPDATE Update the slices
            %   f.UPDATE() updates the slices
            %
            % Optional Parameters:
            %   'uuid' (string): The uuid of the update request. Default is a new uuid.
            arguments
                self fus.ui.FourUp
                uuid string = fus.util.get_uuid
            end
            self.next_render = uuid;
            extent = arrayfun(@extent, self.volume.get_coords, 'UniformOutput', false);
            ii = 0;
            cam_data = self.get_cam_settings(1:3);
            for ax_index = 1:3
                zd = self.zdim(ax_index);
                zi = self.volume.dim_index(zd);
                v = self.volume.isel(zd, self.indices(zi));
                [rgb, alpha] = v.get_image_3d(...
                    self.cmap, ...
                    "xdim", self.volume.dims(1), ...
                    "ydim", self.volume.dims(2), ...
                    "zdim", self.volume.dims(3));
                Xe = v.get_edges();          
                surf_data(ax_index) = struct(...
                    'XData',Xe{1},...
                    'YData',Xe{2},...
                    'ZData',Xe{3},...
                    'CData', squeeze(rgb), ...
                    'AlphaData', squeeze(alpha));
                xyz0 = arrayfun(@(i)repmat(self.values(i),1,2),[1,2,3],'UniformOutput',false);
                jj = 0;
                for j = 1:3
                    if j~=zi
                        xyz = xyz0;
                        xyz{j} = extent{j};
                        ii = ii+1;
                        jj = jj+1;
                        crosshair_data(ii) = struct(...
                            'handle', self.crosshairs(ax_index,jj),...
                            'XData',xyz{1}, ...
                            'YData', xyz{2},...
                            'ZData', xyz{3});
                    end
                end
            end    
            if self.next_render == uuid
                self.render_busy = true;
                for ax_index = 1:3
                    zd = self.zdim(ax_index);
                    zi = self.volume.dim_index(zd);
                    args = fus.util.struct2args(surf_data(ax_index));
                    set([self.image_handles(ax_index) self.surface_handles(ax_index)], args{:});
                    args = fus.util.struct2args(cam_data(ax_index));
                    set(self.axes(ax_index), args{:});
                    for point_index = 1:length(self.points)
                        point = self.points(point_index);
                        xc = point.get_crossection(zd, self.values(zi));
                        set(self.point_handles(ax_index, point_index),...
                            "XData", xc{1}, ...
                            "YData", xc{2}, ...
                            "ZData", xc{3});
                    end
                end
                for ii = 1:length(crosshair_data)
                    args = fus.util.struct2args(rmfield(crosshair_data(ii),'handle'));
                    set(crosshair_data(ii).handle, args{:});
                end
                drawnow
                self.next_render = "";
                self.render_busy = false;
                if ~isempty(self.on_update)
                    self.on_update();
                end
            end
        end
        
        function update_images(self)
            % UPDATE_IMAGES Update the images without re-creating the slices
            %   f.UPDATE_IMAGES() updates the images without re-creating the slices
            for ax_index = 1:3
                zd = self.zdim(ax_index);
                zi = self.volume.dim_index(zd);
                v = self.volume.isel(zd, self.indices(zi));
                [rgb, alpha] = v.get_image_3d(...
                    self.cmap, ...
                    "xdim", self.volume.dims(1), ...
                    "ydim", self.volume.dims(2), ...
                    "zdim", self.volume.dims(3));
                surf_data(ax_index) = struct(...
                    'CData', squeeze(rgb), ...
                    'AlphaData', squeeze(alpha));
            end
            for ax_index = 1:3
                args = fus.util.struct2args(surf_data(ax_index));
                set([self.image_handles(ax_index) self.surface_handles(ax_index)], args{:});
            end
        end
        
    end
    
    methods (Access=protected)
        function set_protected(self, prop, value)
            self.(prop) = value;
        end
        
        function initialize_dims(self)
            % INITIALIZE_DIMS Initialize the dimensions
            arguments
                self fus.ui.FourUp
            end
            if all(arrayfun(@(dim)isequal(self.(dim),["","",""]),["xdim","ydim","zdim"]))
                self.zdim = self.volume.dims;
            end
            for i = 1:3
                [xd, yd, zd] = self.volume.get_xyz(...
                    "xdim", self.xdim(i), ...
                    "ydim", self.ydim(i), ...
                    "zdim", self.zdim(i));
                self.xdim(i) = xd;
                self.ydim(i) = yd;
                self.zdim(i) = zd;
            end
        end
        
        function initialize_axes(self, options)
            % INITIALIZE_AXES Initialize the axes
            arguments
                self fus.ui.FourUp
                options.padding (1,1) double = 40
                options.spacing (1,1) double = 40
                options.axes_arrangement double = [1, 2; 3 4];
                options.parent = [];
                options.colorbar (1,1) logical = false
                options.colorbar_width (1,1) double {mustBePositive} = 0.3;
                options.axes_props (1,1) struct = struct
                options.fig_props (1,1) struct = struct
            end
            if isempty(options.parent)
                f = uifigure("Name", join([self.volume.name], ", "));
                fig_args = fus.util.struct2args(options.fig_props);
                if ~isempty(fig_args)
                    set(f, fig_args{:});
                end
            else
                f = options.parent;
            end
            arr = options.axes_arrangement;
            if options.colorbar && ~any(arr(:)==-1)
                arr = [arr -1*ones(size(arr,1),1)];                
            end
            arrsz = size(arr);
            g = uigridlayout(f, arrsz,...
                'RowSpacing',options.spacing,...
                'ColumnSpacing',options.spacing, ...
                'Padding', repmat(options.padding,1,4));
            if options.colorbar
                g.ColumnWidth = [repmat({'1x'}, 1, arrsz(2)-1), {sprintf('%sx', options.colorbar_width)}];
                cbg = uigridlayout(g, [2, 1]);
                [i,j] = find(arr==-1);
                cbg.Layout.Row = unique([min(i) max(i)]);
                cbg.Layout.Column = unique([min(j) max(j)]);
                cbg.RowHeight = {40,'1x'};
                cbax = uiaxes(cbg);
                cbax.Layout.Row = 2;
                cbax.Layout.Column = 1;
                self.colorbar_axes = cbax;
                self.colorbar_dropdown = uidropdown(cbg);
                self.colorbar_dropdown.Layout.Row = 1;
                self.colorbar_dropdown.Layout.Column = 1;
            end
            ii = 0;
            for ii = 1:4
                ax = uiaxes(g);
                [i,j] = find(arr==ii);
                ax.Layout.Row = unique([min(i),max(i)]);
                ax.Layout.Column = unique([min(j),max(j)]);
                new_axes(ii) = ax;
            end
            axes_args = fus.util.struct2args(options.axes_props);
            if ~isempty(axes_args)
                set(new_axes, axes_args{:});
            end
            self.axes = new_axes;
        end
        
        function initialize_values(self, values)
            % INITIALIZE_VALUES Initialize the slice values
            arguments
                self fus.ui.FourUp
                values (1,:) double = []
            end
            coords = self.volume.get_coords;
            for i = 1:3
                coord = coords(i);
                if isempty(values)
                    self.indices(i) = round(coord.length()/2);
                else
                    self.indices(i) = find(coord.values>=values(i),1);
                end
                self.values(i) = coord.values(self.indices(i));
            end
        end
        
        function create_images_surfaces(self, options)
            arguments
                self fus.ui.FourUp
                options.line_props (1,1) struct = struct()
                options.point_props (1,1) struct = struct('FaceAlpha', 0.2)
            end
            % CREATE_IMAGES_SURFACES Create the images as surfaces
            extent = arrayfun(@extent, self.volume.get_coords, 'UniformOutput', false);
            color_order = {[1,0,0],[0,0.8,0],[0.2,0.2,1]};
            dimx = self.volume.dims(1);
            dimy = self.volume.dims(2);
            dimz = self.volume.dims(3);
            for ax_index = 1:3
                ax = self.axes(ax_index);
                zd = self.zdim(ax_index);
                zi = self.volume.dim_index(zd);
                v = self.volume.isel(zd, self.indices(zi));
                
                im_handles(ax_index) = v.draw_surface(...
                    self.cmap, ...
                    "ax", ax, ...
                    "xdim", dimx, ...
                    "ydim", dimy, ...
                    "zdim", dimz, ...
                    "colorbar", false);
                set(im_handles(ax_index), 'EdgeColor',color_order{ax_index});
                surf_handles(ax_index) = copyobj(im_handles(ax_index), self.axes(end));
                hold(self.axes(end), "on");
                hold(ax, "on");
                xyz0 = arrayfun(@(i)repmat(self.values(i),1,2),[1,2,3],'UniformOutput',false);
                jj = 0;
                for j = 1:3
                    if j~=zi
                        idx = [1,2,3];idx([zi,j]) = [];
                        options.line_props.Color = color_order{idx};
                        lineargs = fus.util.struct2args(options.line_props);
                        xyz = xyz0;xyz{j} = extent{j};
                        jj = jj+1;
                        new_crosshairs(ax_index,jj) = plot3(...
                            ax, ...
                            xyz{:},...
                            lineargs{:}, ...
                            'HitTest','off');
                    end
                end
                for point_index = 1:length(self.points)
                    point = self.points(point_index);
                    xc = point.get_crossection(zd, self.values(zi));
                    options.point_props.FaceColor = point.color;
                    options.point_props.HitTest = "off";
                    point_args = fus.util.struct2args(options.point_props);
                    self.point_handles(ax_index, point_index) = patch(...
                        ax, xc{:}, point.color, point_args{:});
                end
                axis(ax,'image','xy');
                set(ax, 'ButtonDownFcn', @self.button_down_callback);% {@hittest, self}) 
                axtoolbar(ax, {'zoomin', 'pan'});
                ax.UserData.Name = sprintf('Axis %d', ax_index);
                set(im_handles(ax_index),'HitTest','off');
            end
            if ~isfield(options.point_props, "FaceAlpha")
                options.point_props.FaceAlpha = 0.3;
            end
            for point_index = 1:length(self.points)
                point = self.points(point_index);
                point.draw("ax", self.axes(4), "FaceAlpha", options.point_props.FaceAlpha);
            end
            coords = self.volume.get_coords();
            xlabel(self.axes(end), coords.by_id(dimx).label);
            ylabel(self.axes(end), coords.by_id(dimy).label);
            zlabel(self.axes(end), coords.by_id(dimz).label);
            self.crosshairs = new_crosshairs;
            self.image_handles = im_handles;
            self.surface_handles = surf_handles;
            axis(self.axes(end),'image','xy');
            self.links = linkprop([self.axes self.axes(end)], ["XLim", "YLim", "ZLim"]);
            
            if ishandle(self.colorbar_dropdown)
                self.cmap_ui = fus.ui.ColorMapper_UI(...
                    self.cmap(1), ...
                    "axes", self.colorbar_axes, ...
                    "on_update", @self.update_images,...
                    "range", self.volume(1).percentile([0, 1]));
                set(self.colorbar_dropdown, ...
                    "Items", [self.volume.name], ...
                    "ItemsData", [self.volume.id], ...
                    "Value", self.volume(1).id, ...
                    'ValueChangedFcn', @self.set_cmap ...
                    )
            end
            
            self.reset_view()
            axtoolbar(self.axes(end), {'rotate', 'zoomin', 'restoreview'});
        end
        
        function cam_settings = get_cam_settings(self, axis_index)
            % GET_CAM_SETTINGS Get the camera settings for the given axis.
            %
            % Optional Parameters:
            %   'axis_index' (int): The axis index. Default is [1, 2, 3].
            arguments 
                self fus.ui.FourUp
                axis_index (1,:) double {mustBeMember(axis_index, [1,2,3])} = [1,2,3]
            end
            vectors = eye(3);
            extent = arrayfun(@extent, self.volume.get_coords, 'UniformOutput', false);
            dext = cellfun(@diff, extent);
            center = cellfun(@mean, extent);
            for ii = 1:length(axis_index)
                ax_index = axis_index(ii);
                xi = self.volume.dim_index(self.xdim(ax_index));
                yi = self.volume.dim_index(self.ydim(ax_index));
                zi = self.volume.dim_index(self.zdim(ax_index));
                cam_target = center;
                cam_target(zi) = self.values(zi);
                cam_position = center;
                cam_position(zi) = mean(extent{zi});                
                cam_pullback_vec = cross(vectors(xi,:),vectors(yi,:));
                cam_position = cam_position+cam_pullback_vec*dext(zi)*(1+self.axis_margin+0.1)/2;
                cam_settings(ii) = struct(...
                    'CameraTarget', cam_target, ...
                    'CameraPosition', cam_position,...
                    'CameraUpVector',vectors(yi,:));
            end
        end
        
        function set_cmap(self, src, eventdata)
            index = find(src.Value == [self.volume.id]);
            cla(self.colorbar_axes);
            self.cmap_ui = fus.ui.ColorMapper_UI(...
                self.cmap(index), ...
                "axes", self.colorbar_axes, ...
                "on_update", @self.update_images, ...
                "range", self.volume(index).percentile([0, 1]));
        end
        
        function button_down_callback(self, ax, event)
            fig = ancestor(ax, 'figure');
            prev_callbacks = {fig.WindowButtonMotionFcn, fig.WindowButtonUpFcn};        
            lastwarn('', '');
            warnings = ["MATLAB:modes:mode:InvalidPropertySet", "MATLAB:callback:DynamicPropertyEventError"];
            for i = 1:length(warnings)
                s(i) = warning('QUERY', warnings(i));
                warning('off', warnings(i));
            end
            set(fig, "WindowButtonUpFcn", {@self.window_up_fcn, ax, prev_callbacks});
            if ~isempty(fig.WindowButtonUpFcn)
                set(fig, "WindowButtonMotionFcn", {@self.window_motion_fcn, ax});
            end
            for i = 1:length(warnings)
                warning('on', warnings(i));
            end
            self.update_position(ax);
        end
        
        function update_position(self, ax)
            cp = ax.CurrentPoint;
            i = find(diff(cp)~=0, 1);
            coords = self.volume.get_coords;
            new_indices = self.indices;
            for j = 1:3
                if i ~= j
                    coord = coords(j);
                    index = interp1(coord.values,[1:coord.length], cp(1,j), 'nearest');
                    if ~isnan(index)
                        new_indices(j) = index;
                    end
                end
            end
            self.set_indices(new_indices);
        end
        
        function window_motion_fcn(self, src, event, ax)
            self.update_position(ax);
        end
        
        function window_up_fcn(self, src, event, ax, prev_callbacks)
            fig = ancestor(ax, "figure");
            set(fig, "WindowButtonMotionFcn", '', "WindowButtonUpFcn", '');
        end
            
    end
end